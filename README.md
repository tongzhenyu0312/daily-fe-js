### 1.0
1. 变量的值住在哪里？存储在哪里？程序需要时如何找到他们？   
提供答案的是一套规则: 作用域

### 1.1
1. 传统的程序的源码在被执行前会发生什么事？   
 “编译”。 JS的编译包含(分词/词法分析+语法分析+生成机器码)这三个步骤。

2. 分词/词法分析 指的是什么？   
 tokenizing/lexing 都是指将 代码字符 分解为对编程语言来说有意义的代码块(词法单元token)组成的词法单元流(数组)。tokenizing/lexing的区别在于对token的识别方式(有无状态)，这里不深究。

3. 词法分析 指的是什么？   
 Parsing阶段 会将 词法单元流 重新组装成一个 元素嵌套的 代表程序语法结构的 树(AST 抽象语法数)。

4. 生成机器码 指的是什么？   
如题，将上一步的AST转换为机器可以直接执行的指令(该步骤与平台和编程语言息息相关，可能是二进制)。

5. JS的编译与传统的程序编译有什么区别？
    - JS的编译并非发生在构建之前
    - 在语法分析和生成机器码阶段会有大量的优化操作
    - JS的编译仅发生执行前几微秒

### 1.2.1
```js
这里声明下三个角色：
引擎：工头 -负责监督程序的编译，最后亲自执行
编译器：小工 -负责执行代码的编译
作用域：记录员组织 -负责对声明的变量的收集，并且提供一套严格的对变量的查询系统。
```
    
### 1.2.2
1. 描述var a = 2;的编译执行过程？   
    - 引擎接到源码，通知编译器编译；
    - 编译器执行词法分析和语法分析(注意生成 声明的ast节点时 会询问当前作用域是否已经有记录，如果已经登记过，则跳过该步骤，继续编译)，最后生成机器码(机器码的含义是声明一个变量，分配存储空间，并且存储值2进入改空间)
    - 引擎执行机器码，执行到a=2阶段时，询问作用域变量a记录的值，如果作用域找不到，则会到更高层的作用域中查找。如果查找不到，引擎将抛出一个异常。   
总结：一个简单的赋值操作，涉及到 编译器在当前作用域声明改变量(如果作用域中原不存在该变量)，引擎执行过程中，询问作用域访问到该变量，并进行赋值。

### 1.2.3
1. 变量的访问可以有 var a = 2; 和 console.log(a); 这两种形式，那么引擎执行代码时对变量的访问方式，是否一致？   
对变量的查询包含两种方式：LHS(查询的目的是赋值) 和 RHS（查询的目的是取值）

```js
function foo(a)  {
    console.log( a ); // RHS
}
foo( 2 ); // LHS
```
声明函数时，编译器在语法分析阶段就已经完成 变量的声明与定义。
```js
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );
// 判断引擎对LHS和RHS查询的使用情况：
foo RHS
a LHS
a RHS
b LHS
a+b RHS RHS
c LHS
```

### 1.3 作用域链
- 简单的介绍下 作用域链？   
作用域是查找变量的一套规则，其中的规则之一就是作用域链，在当前作用域中找不到变量，会去上级作用域查找，一直查到全局作用域(也就是作用域是一个组织 ヽ(*。>Д<)o゜)。


### 1.4 异常
1. 关于LHS与RHS在面对 查询异常的困境时，引擎会分别执行什么机制？
```js
function foo(a) {
    console.log( a + b );
}
foo( 2 );
```
引擎会对变量b进行RHS查询，若直到全局作用域都找不到时，引擎会抛出
`ReferenceError`。   

```js
function foo(a) {
    b = a;
}
foo( 2 );
```
引擎对b进行LHS查询，同样到全局作用域都找不到时(严格模式抛出ReferenceError，非严格模式会创建全局变量b)   

> 注意这里引申一个对于异常的介绍    TypeError(指RHS查询已经成功，不过对值进行了非其类型的异常操作，比如值是基本数据类型，却进行函数类型数据的操作)   

总结： 
- `ReferenceError`指 `作用域判定失败(找不到变量住的家)`    
- `TypeError`指`作用域判定成功，但是对结果的操作非法(找到了家，但是人不对，小工干不了电工的活)`。


### 2.1 词法阶段

1. 介绍下词法作用域？   
词法作用域 是为了区分 动态作用域(bash等语言会用到)，JS中只有 词法作用域(定义在词法分析阶段作用域) 存在。   
词法作用域 是在 编译器进行词法分析(单词化)阶段创建的，所以词法作用域的位置和嵌套关系是根据`代码书写时函数声明的位置`所决定的。

2. 作用域变量查询的特点？
    - 逐级向上，直到全局
    - 查询到第一个匹配项即停止(查询具有遮蔽效应)
    - 只会查询一级标识符，foo.bar这种，只会查询foo，而后作用域规则失效，对象属性访问规则继续支持查询。

### 2.2 欺骗词法
1. 介绍下如何欺骗词法作用域？
    - eval
    - with   
这两种方式都会改变 “当前的”词法作用域(比如执行的代码中有声明)，并且会影响 编译器编译的各个阶段的优化，所以需要避免使用。

### 3.1 函数中的作用域
1. 介绍下函数作用域？   
前面说过词法作用域 定义于词法分析阶段，是根据代码书写的函数声明生成的。   
函数作用域指的是，函数内部的变量都可以在函数范围及其嵌套的函数范围内查询到。

### 3.2 隐藏内部实现
1. 如何理解函数？   
写一个函数指声明一个函数，然后在其内书写逻辑，反过来可以理解 对一段逻辑的隐藏。   
书写函数本身就符合 软件设计 的 最小暴露原则（指只提供最少的接口暴露，内部变量与函数私有化，不可访问）。   
隐藏内部实现或者说书写函数，本身就可以通过函数的作用域，避免命名冲突。

2. 除了函数，还有哪些常见的避免命名冲突的手段？
  - 命名空间
  - 模块化

### 3.3 函数作用域
1. 通过函数隐藏内部实现，有什么副作用？是否有好的解决方案？   
通过函数隐藏内部实现，引擎在外部作用域内无法查询内部变量与任何实现。   
但是这样需要声明一个函数，也会造成在外部作用域中多添加了一个函数声明，“污染”了外部作用域。   
解决方案就是：`自执行函数`。

### 3.3.2 立即执行函数表达式IIFE
1. 如何理解自执行函数IIFE？
函数的存在形式只有两种：`函数表达式`还是`函数声明`，这将决定`函数的名称标识符是绑定在何处`。
定义两者，由此作出区分的依据很简单：`function 关键字 字符是否是该行第一个字符`。   
根据上述依据，可以得出`自执行函数是函数表达式`的结论。   
这决定了，`函数名标识符将绑定在函数本身作用域内`，因此可以解决 通过函数实现隐藏内部实现的副作用。

2. 函数可以进行哪些分类？
    - 函数声明 vs 函数表达式（就函数的存在形式而言）
    - 匿名函数(所有匿名函数都属于函数表达式) vs 具名函数 (就函数是否有名称而言)
匿名函数会给调试带来困难，始终给函数命名是一个良好的习惯。

3. IIFE在最开始的`词法分析阶段`会生成其`函数作用域(词法作用域) `么？
我理解不会。   
我认为 IIFE的作用域是在 引擎执行阶段生成。
它与eval不同，不是改变当前作用域，而是生成了一个新的嵌套的函数作用域。

### 3.4 块级作用域
1. 函数可以作为一种常见的作用域单元来隐藏声明的变量和函数，那么是否有其他方案？   
块级作用域。   
`try{...}catch(e){...}`的catch块就是利用的 块级作用域。

2. 关于作用域闭包，你有什么想说的？
我理解：   
闭包存在的意义，是通过一个嵌套的作用域A，能够访问另一个作用域B。   
闭包存在的前提，是作用域链的存在。   
闭包的含义，其实就是一个封闭的作用域。   
身处父作用域内，无法影响其内部嵌套的作用域，这个作用域对于我们来说就是封闭的，但是通过 闭包，可以访问到一些 嵌套的作用域 愿意提供给我们的一些数据或者实现。   

> 无论通过何种手段将内部函数(函数作用域)传递到 函数所在的词法作用域 以外，它都会持有对 原始定义作用域 的引用，无论在何处执行这个函数都会使用闭包。  

3. 简单介绍下闭包的使用场景？   
在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

4. 通过函数表达式生成的函数，是否会在词法分析阶段被收集(提升是否等于收集)？   

> 词法分析阶段会生成 词法作用域来收集所有声明(函数声明 var变量声明),函数表达式不会进行变量提升。

从函数表达式和函数声明是两个概念来看：词法作用域不会收集函数表达式   
佐证就是：函数表达式的函数名都是被收集在函数本身的作用域内。   
综上所述：提升和收集 仅从es5的角度看，是一致的。   

5. 函数作用域属于词法作用域，那么块作用域是否也是词法作用域的一种？   
我理解：块作用域是在运行时被定义的，定义的规则是由let声明(let声明的变量不会被词法作用域收集)。

### 4 提升
1. 提升发生在什么阶段，是编译时还是运行时？    
我理解：提升发生在编译时，且是在词法分析阶段的收集声明时完成的。



